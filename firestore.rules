rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // Helper function to check if user is authenticated
    function isAuthenticated() {
      return request.auth != null;
    }
    
    // Helper function to get user data
    function getUserData() {
      return get(/databases/$(database)/documents/users/$(request.auth.uid)).data;
    }
    
    // Helper function to check if user is an admin
    function isAdmin() {
      return isAuthenticated() && 
             exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
             getUserData().role == 'admin';
    }
    
    // Helper function to check if user is a doctor
    function isDoctor() {
      return isAuthenticated() && 
             exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
             getUserData().role == 'doctor';
    }
    
    // Helper function to check if user is a patient
    function isPatient() {
      return isAuthenticated() && 
             exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
             getUserData().role == 'patient';
    }
    
    // Helper function to check if user owns the resource
    function isOwner(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }
    
    // Helper function to check if user's email matches the document email
    // Used when creating/updating doctor or patient records
    function emailMatches() {
      return isAuthenticated() && 
             exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
             request.resource.data.email == getUserData().email;
    }
    
    // Helper function to check if patient email matches user email
    // Used when reading patient records
    function isOwnPatientRecord() {
      return isAuthenticated() && 
             exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
             resource.data.email == getUserData().email;
    }
    
    // Users collection - all authenticated users can read for connections
    match /users/{userId} {
      allow read: if isAuthenticated();
      allow create: if isAuthenticated() && isOwner(userId);
      allow update: if isAuthenticated() && (isOwner(userId) || isAdmin());
      allow delete: if isAuthenticated() && (isOwner(userId) || isAdmin());
    }
    
    // Doctors collection
    match /doctors/{doctorId} {
      // Anyone authenticated can read doctors
      allow read: if isAuthenticated();
      
      // Allow creation if:
      // 1. User is an admin, OR
      // 2. User is creating their own record during registration (email matches)
      allow create: if isAuthenticated() && (
        isAdmin() || 
        emailMatches()
      );
      
      // Allow update if:
      // 1. User is an admin, OR
      // 2. User is updating their own record (email matches)
      allow update: if isAuthenticated() && (
        isAdmin() || 
        (emailMatches() && resource.data.email == request.resource.data.email)
      );
      
      // Only admins can delete
      allow delete: if isAdmin();
    }
    
    // Patients collection
    match /patients/{patientId} {
      // Allow read if:
      // 1. User is a doctor or admin, OR
      // 2. User is reading their own record (email matches)
      allow read: if isAuthenticated() && (
        isDoctor() || 
        isAdmin() || 
        isOwnPatientRecord()
      );
      
      // Allow creation if:
      // 1. User is an admin, OR
      // 2. User is creating their own record during registration (email matches)
      allow create: if isAuthenticated() && (
        isAdmin() || 
        emailMatches()
      );
      
      // Allow update if:
      // 1. Admin can update anything (including assignedDoctor)
      // 2. Doctor can update but cannot change assignedDoctor field
      // 3. User can update their own record but cannot change assignedDoctor field
      allow update: if isAuthenticated() && (
        // Admin can update anything
        isAdmin() ||
        // Doctor can update but assignedDoctor must remain unchanged
        (isDoctor() && 
         (resource.data.assignedDoctor == request.resource.data.assignedDoctor || 
          !('assignedDoctor' in request.resource.data))) ||
        // User updating own record but assignedDoctor must remain unchanged
        (emailMatches() && 
         resource.data.email == request.resource.data.email &&
         (resource.data.assignedDoctor == request.resource.data.assignedDoctor || 
          !('assignedDoctor' in request.resource.data)))
      );
      
      // Only admins can delete
      allow delete: if isAdmin();
      
      // Patient health data subcollection
      match /healthData/{healthDataId} {
        // Allow read if:
        // 1. User is a doctor or admin, OR
        // 2. User is reading their own patient record's health data
        allow read: if isAuthenticated() && (
          isDoctor() || 
          isAdmin() || 
          isOwnPatientRecord()
        );
        
        // Only doctors and admins can create health data
        allow create: if isAuthenticated() && (isDoctor() || isAdmin());
        
        // Only doctors and admins can update health data
        allow update: if isAuthenticated() && (isDoctor() || isAdmin());
        
        // Only doctors and admins can delete health data
        allow delete: if isAuthenticated() && (isDoctor() || isAdmin());
      }
    }
    
    // Connections collection
    match /connections/{connectionId} {
      // Helper function to check if user is involved in the connection
      function isInvolved() {
        return isAuthenticated() && (
          resource.data.user1 == request.auth.uid ||
          resource.data.user2 == request.auth.uid
        );
      }
      
      // Helper function to check if user is involved in the new connection
      function isInvolvedInNew() {
        return isAuthenticated() && (
          request.resource.data.user1 == request.auth.uid ||
          request.resource.data.user2 == request.auth.uid
        );
      }
      
      // Users can read their own connections or connections where they are involved
      // Allow read if document doesn't exist (for checking before create) or if user is involved
      allow read: if isAuthenticated() && (
        !resource.exists ||
        resource.data.user1 == request.auth.uid ||
        resource.data.user2 == request.auth.uid
      );
      
      // Users can create connections if they are one of the users in the connection
      // and they are the one requesting (requestedBy must be their uid)
      allow create: if isAuthenticated() && 
        (request.resource.data.user1 == request.auth.uid ||
         request.resource.data.user2 == request.auth.uid) &&
        request.resource.data.requestedBy == request.auth.uid &&
        request.resource.data.status == 'pending';
      
      // Users can update connections if they are involved
      // Only allow status updates (accept/reject)
      allow update: if isAuthenticated() && (
        (resource.data.user1 == request.auth.uid ||
         resource.data.user2 == request.auth.uid) &&
        // Only allow updating status and updatedAt fields
        (!('user1' in request.resource.data) || request.resource.data.user1 == resource.data.user1) &&
        (!('user2' in request.resource.data) || request.resource.data.user2 == resource.data.user2) &&
        (!('user1Role' in request.resource.data) || request.resource.data.user1Role == resource.data.user1Role) &&
        (!('user2Role' in request.resource.data) || request.resource.data.user2Role == resource.data.user2Role) &&
        (!('requestedBy' in request.resource.data) || request.resource.data.requestedBy == resource.data.requestedBy) &&
        (!('createdAt' in request.resource.data) || request.resource.data.createdAt == resource.data.createdAt) &&
        // Status must be valid
        request.resource.data.status in ['pending', 'accepted', 'rejected']
      );
      
      // Users can delete their own connections
      allow delete: if isAuthenticated() && (
        resource.data.user1 == request.auth.uid ||
        resource.data.user2 == request.auth.uid
      );
    }
  }
}

